import heapq

class PuzzleNode:
    def __init__(self, state, parent=None, move=None, depth=0):
        self.state = state
        self.parent = parent
        self.move = move
        self.depth = depth

    def __lt__(self, other):
        return (self.depth + self.manhattan()) < (other.depth + other.manhattan())

    def manhattan(self):
        total_distance = 0
        for i in range(3):
            for j in range(3):
                if self.state[i][j] != 0:
                    row_goal, col_goal = divmod(self.state[i][j] - 1, 3)
                    total_distance += abs(i - row_goal) + abs(j - col_goal)
        return total_distance

    def is_goal(self):
        return self.manhattan() == 0

    def generate_children(self):
        children = []
        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 0:
                    for move in moves:
                        new_i, new_j = i + move[0], j + move[1]
                        if 0 <= new_i < 3 and 0 <= new_j < 3:
                            new_state = [list(row) for row in self.state]
                            new_state[i][j], new_state[new_i][new_j] = new_state[new_i][new_j], new_state[i][j]
                            children.append(PuzzleNode(new_state, parent=self, move=(i, j), depth=self.depth + 1))
        return children

def solve_puzzle(initial_state):
    initial_node = PuzzleNode(initial_state)
    visited_states = set()
    min_heap = []
    heapq.heappush(min_heap, initial_node)

    while min_heap:
        current_node = heapq.heappop(min_heap)
        if current_node.is_goal():
            return get_solution_path(current_node)
        
        visited_states.add(tuple(map(tuple, current_node.state)))

        for child in current_node.generate_children():
            if tuple(map(tuple, child.state)) not in visited_states:
                heapq.heappush(min_heap, child)

    return None

def get_solution_path(node):
    path = []
    while node:
        path.append((node.state, node.move))
        node = node.parent
    path.reverse()
    return path

# Example initial state (8-Puzzle)
initial_state = [[1, 2, 3],
                 [0, 4, 5],
                 [6, 7, 8]]

# Solve the puzzle
solution_path = solve_puzzle(initial_state)

# Print the solution path
for state, move in solution_path:
    print("Move:", move)
    for row in state:
        print(row)
    print()
